% ------ APPENDIX B ------

\chapter{Programmer manual}
% ------ APPENDIX INTRO ------
This appendix explains how the two implementations are designed. In particular, there is a first section about the frameworks and the libraries used, followed by the implementation itself (with code explanations, problems, resolutions, endpoints and messages exchanged in practice) for both the examples. Finally, the last section is devoted to the compilation and dockerization of the solutions.
% ------ END OF APPENDIX INTRO ------

% ------ SECTION B.1 ------
\section{Frameworks, libraries and environment}
For what concerns the second demo and the server of the first demo, it has been used Apache Maven as build automation tool and the only requirement is Java JDK8 installed. Moreover, since Maven is integrated into the project (by using maven-wrapper), there is no need to install it on the machine.
For what concerns the client in the first demo, React is the Javascript framework chosen. The programs \texttt{npm} and \texttt{node} must be installed on the machine (see \url{https://www.npmjs.com/get-npm} to get both of them). 
The code of the implementation examples is available on GitHub:

\begin{itemize}
    \item \textbf{\oauth\ with Google/Facebook}\footnote{\url{https://github.com/nopesir/oauth-hw-security}}
    \item \textbf{\oauth\ with custom AuthZ/Resource servers}\footnote{\url{https://github.com/nopesir/oauth-hw-security-custom}}
\end{itemize}

Last but not least, both \textit{Docker} and \textit{Docker-Compose} must be installed too to dockerize the solutions. For instructions, see (\ref{appa}).
% ------ END OF SECTION B.1 ------

% ------ SECTION B.2 ------
\section{Implementation}
In this section are analyzed the design and implementation of the two solutions with messages exchanged and endpoints used. The "Playground" demo provided by OAuth.com in collaboration with Okta \cite{playgr} can be very helpful for the developer to understand the flows and the protocol from a practical point of view. 

% ------ SECTION B.2.1 ------
\subsection{\oauth\ with Google/Facebook}
The \textit{server-side} is a Spring Boot application that uses \oauth\ by exploiting Spring Security in order to implement both social (Google/Facebook/GitHub) and email/password logins (with a MySQL database). On the other hand, the \textit{client-side} application is not strictly related to \oauth, but it is an example on how to use the information provided by the \oauth\ Spring Boot server to interact with an end-user (in this case, a React web application). Since the flow with some providers varies for what concerns payloads types and endpoints, of particular relevance are the official documentations from Facebook \cite{facebook} and Google \cite{google1, google2}. Furthermore, to implement the Spring Boot server, a good example can be found on the developer.okta.com's blog \cite{sprboot}. 

The implemented flow's main actor is the Spring Boot server, that acts as a \oauth\ client. The objective of this implementation is to retrieve basic User information (name and email) from the Google account by using the \textit{Authorization Grant flow}. More in details, this is done through a React web-app that consumes the server's APIs. The first interaction takes place as follows (for more details on the messages exchanged, see Fig.~\ref{fig:google1}):

\begin{figure}[h]
    \centering
    \includegraphics[width=0.85\textwidth]{chapters/images/chp6/flow_google1.png}
    \caption{Implementation of the AuthZ Code Grant flow with Google. Part 1.}
    \label{fig:google1}
\end{figure}

\begin{enumerate}
    \item From the "Login" page, the user clicks on "Login With Google" and a first redirection starts on \url{http://localhost:8080/oauth2/authorize/google} with the requested params.
    \item The server creates the state param, takes the info from the configuration and redirects the user to the Google \oauth\ page (\url{https://accounts.google.com/o/oauth2/v2/auth}).
    \item Here the user logs in on Google and Accepts/Denies the AuthZs scopes. After the user acceptance, Google redirects it back on the server with the AuthZ Code.
    \item The server checks that the state is the same and prepares a HTTP GET to the Google Token endpoint (this is done automatically by Spring Security, no action is required by the user).
    \item Google checks code, secrets and gives a JWT access token and refresh token in a JSON object.
    \item The server saves the token.
\end{enumerate}

The second interaction starts in order to let the server populate the database by consuming the received token and giving a local token to the React web-app in order to let the app access the stored information in the database (Fig.~\ref{fig:google2}):

\begin{figure}[h]
    \centering
    \includegraphics[width=0.85\textwidth]{chapters/images/chp6/flow_google2.png}
    \caption{Implementation of the AuthZ Code Grant flow with Google. Part 2.}
    \label{fig:google2}
\end{figure}

\begin{enumerate}
    \item[7.] The server sends an HTTP GET to the Google endpoint \url{https://googleapis.com/oauth2/v2/userinfo} by inserting the \texttt{access\_token} in the authorization header. The Google API server checks the token and prepares the response as JSON.
    \item[8.] The Spring server saves the access token and updates the information in the database. It creates a local JWT token to give it to the client app.
    \item[9.] The React app saves the token  (that is not the \oauth\ token) into a cookie and uses it to get the user info from the endpoint of the Spring server \url{http://localhost:8080/user/me} by attaching the local token into the authorization header.
    \item[10.] The server checks for the token and responds with the JSON of the logged user by formatting a JSON from the database info.
    \item[11.] Finally, the React app displays the information of the logged user.
\end{enumerate}

After this introduction on the general flow, in the following subsections is presented a detailed explanation of the implementation, divided into the two modules that compose the architecture.

\subsubsection{Client-side}
As mentioned before, this application is pretty simple and it is only used as an interface between the \oauth\ Spring Boot back-end server and the user to display information. An alternative could be directly to implement into the Spring Boot back-end the web-server.

\begin{wrapfigure}[20]{r}{0.30\textwidth}
  \begin{center}
    \includegraphics[width=0.30 \textwidth]{chapters/images/chp6/dirreact.jpg}
  \end{center}
  \caption{Final directory tree of the \texttt{react-social} app}
  \label{fig:dirtree}
\end{wrapfigure}

\noindent To create the base React application, simply type:

  \texttt{\$ npm install -g create-react-app}
  
  \texttt{\$ create-react-app react-social}

\noindent And then add the dependencies for routing and alerts:

  \texttt{\$ cd react-social}
  
  \texttt{\$ npm install react-router-dom react-s-alert --save}

\noindent That is the base React application to build on. We have to populate and organize the final directory structure to look like in Fig.~\ref{fig:dirtree}.

The code is pretty self-explanatory, but there are some important aspects to consider. The first one is \textbf{index.js}, that is the entry-point of the application. It renders the App component in a document object model that has \texttt{root} as id and it is subsequently wrapped into a Router to enable client-side routing. The second important aspect is \textbf{App.js}, located in \texttt{src/app}. It is the top-level element of the application and is responsible for the layout, the routes and manages the authentication by loading the details from the back-end of the current user, forwarding it to the child components. The \textbf{Login.js} file, located in \texttt{src/user/login}, is responsible for the \oauth\ login and the username/password login, while \textbf{OAuth2RedirectHandler.js} is the component called by the Spring Boot server when the user has completed the \oauth\ flow on it. In particular, once that the server flow is finished, the server saves all the information in a database and generates a local token. This component will receive a bearer token from the Spring Boot server (note that this token is not related to \oauth, it is a token generated by the Spring Boot server to manage the access to the database information) or an error otherwise.

Last but not least, the \textbf{index.js} located in \texttt{src/constants} contains information about the endpoints. The \texttt{API\_BASE\_URL} refers to the Spring Boot server base URL, that represents the API for the \textit{hw-client} app. The \texttt{OAUTH2\_REDIRECT\_URI} is the redirection URI where the \\ \textbf{OAuth2RedirectHandler.js} is waiting to handle the response and the three \texttt{PROVIDER\_AUTH\_URL} are the Spring Boot server URLs called when the user clicks on one of the three \oauth\ login, passing as parameter a \texttt{redirect\_uri} to let the server know where to redirect the local token once that he has completed the AuthZ Code Grant flow. 

\begin{figure}[h!]
    \centering
    \fbox{\includegraphics[width=16cm]{chapters/images/chp6/spring.png}}
    \caption{Spring Boot base project selection}
    \label{fig:spring}
\end{figure}

\subsubsection{Registration process}
\label{regprocess}
To enable the Spring Boot server to perform a social login with an \oauth\ provider, the first step is to create an application in the provider's developer console and obtain the \texttt{client\_id} and \texttt{client\_secret}. These two strings are used by the providers (Google, Facebook and so on) to identify our server application. Besides, there are some other parameters to consider:

\begin{itemize}
    \item \textit{Authorized redirect URIs}: After that the AuthZ Grant Flow finishes, the provider needs this URI to understand where the user has to be redirected after the flow and what are the ones that are authorized by the developer.
    \item \textit{Scopes}: They represent \textbf{what} can be granted. Note that this is only meant to enable the possibility to give it, it is not automatically given to our server. The user will decide what scopes from the enabled scopes can be consumed by the Spring Boot server.
\end{itemize}

\noindent To create an app, simply start a new app in one of the following provider's page:

\begin{itemize}
    \item Google Project: \url{https://console.developers.google.com/}
    \item Facebook: \url{https://developers.facebook.com/apps}
    \item GitHub: \url{https://github.com/settings/apps}
\end{itemize}

\noindent Set the Authorized redirect URIs (more on this in the next subsection), the scopes (email, name) and retrieve the two secrets for each provider.

\subsubsection{Server-side}

\begin{wrapfigure}[15]{r}{0.3\textwidth}
  \begin{center}
    \includegraphics[width=0.3 \textwidth]{chapters/images/chp6/springdir.jpg}
  \end{center}
  \caption{Final directory tree of the \texttt{spring-social} app}
  \label{fig:dirsocial}
\end{wrapfigure}

The server, as it has already mentioned, is a Spring Boot application. The base project can be automatically created using Spring Initializr\footnote{Start the project from \url{https://start.spring.io/}}. In particular, the selections are the ones in Fig.~\ref{fig:spring}.

Then, the project folder has been modified to have the directory structure in Fig.~\ref{fig:dirsocial}. Furthermore, two more dependencies must be added to the project (not available on Spring Initializr): \textit{\oauth\ Client} and \textit{JWT Library}. By opening the \texttt{pom.xml} file, thanks to Maven, simply add these lines into the \texttt{<dependencies></dependencies>} tags:

\begin{lstlisting}[language=XML, basicstyle=\fontsize{9}{11}\ttfamily]
  <!-- OAuth2 Client -->
  <dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-oauth2-client</artifactId>
  </dependency>

  <!-- JWT library -->
  <dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.5.1</version>
  </dependency>
\end{lstlisting}

\noindent Now that the Spring Boot app structure is ready, we are going to analyze every Java file and configuration file to understand how the functionalities are implemented. The configuration file is \textbf{application.yml} (note that if a file has \texttt{.template} as extension it represents a simple file without this extension with some variables to be changed at build time, see \ref{docker} for more information). The configuration file is located in \texttt{src/main/resource/} and it contains all the information about the database, the redirection URIs and so on. In \texttt{spring.datasource} are saved the MySQL database variables, while in \texttt{spring.security.oauth2} we can find everything that concerns \oauth\ providers and their details. In particular, for each provider, we can insert the two secrets (\texttt{clientId} and \texttt{clientSecret}) with the redirect URI and the scopes.

In a few words, all the content stored in \texttt{spring} is related to the server itself, while \texttt{app} is used to authenticate the React web application. More in details, \texttt{app.auth} information is consumed for the creation of a JWT authentication token (that has nothing to do with \oauth) that is passed to the React front-end (or any other front-end, as a mobile app) by a redirection to \\ \url{http://localhost:9090/oauth2/redirect} (enabling \textbf{OAuth2RedirectHandler.js}) or for example \url{myandroidapp://oauth2/redirect} if the front-end is a mobile app.
After successfully authenticating with the \oauth\ Provider, the Spring Boot server will generate an AuthN token for the user and will send the token to the \texttt{redirectUri} mentioned by the front-end client in the \texttt{/oauth2/authorize} request. 

The next step is to load this configuration file and bind the properties. The \\ \texttt{@ConfigurationProperties} feature is used in \textbf{AppProperties.java} to load the \texttt{app} information from the configuration file and is enabled with  \texttt{@EnableConfigurationProperties} in the main file \textbf{SpringSocialApplication.java}. Moreover, to enable CORS\footnote{Cross-Origin Resource Sharing, "[...] a mechanism that uses additional HTTP headers to tell browsers to give a web application running at one origin, access to selected resources from a different origin.". Source: \url{https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS}} is created a \textbf{WebMvcConfig.java}  so that our front-end can access the APIs from different origins. The used restrictions are pretty low for the demo, but in production environments they must be restricted.

To enable the database interaction, the database entities must be created. The User entity is available in the \textbf{User.java} file, alongside the \texttt{enum} \textbf{AuthProvider.java} that represents the provider. The implementation of the database functionalities is denoted to the \textbf{UserRepository.java} interface. Here it is used \textit{Spring-Data-JPA} to build a repository layer to access the database information.
Once that the configuration, the entity classes and repositories are ready, we will use \textit{Spring Security} \cite{sprsec} to perform the \oauth\ social login as well as the password/email based login.

The core of the \oauth\ Security on the server is \textbf{SecurityConfig.java}, that binds all the constituents to implement a security policy for the entire application. In particular, \textbf{SecurityConfig.java} is an extension of \textbf{WebSecurityConfigurerAdapter.java} and overrides some of its methods to provide custom security configurations:

\begin{itemize}
    \item \textit{CustomUserDetailsService}
    \item \textit{CustomOAuth2UserService}
    \item \textit{OAuth2AuthenticationSuccessHandler}
    \item \textit{OAuth2AuthenticationFailureHandler}
    \item \textit{HttpCookieOAuth2AuthorizationRequestRepository}
    \item \textit{TokenAuthenticationFilter}
    \item And all the classes implemented in \texttt{java.com.example.springsocial.security}
\end{itemize}

\noindent The flow starts with the front-end client. After that one of the three available \oauth\ login buttons is clicked, the React app redirects the user to \\

\vspace{0.1cm}

\hypertarget{foo}{}

\textcolor{blue}{\texttt{\footnotesize{http://localhost:8080/oauth2/authorize/\{provider\}?redirect\_uri=<redirect\_uri\_after\_login>}}} \\

\vspace{0.1cm}

\noindent Where \texttt{localhost:8080} is the Spring Boot server base URL, \texttt{provider} represents one of the three providers and the \texttt{redirect\_uri} is the URI to which the user will be redirected after the \oauth\ flow on the provider site (note that this redirection is not the \oauth\ \texttt{redirectionUri}).

Once that the authorization request is received, Spring Security's \oauth\ redirects the user on the \textit{AuthorizationUrl} of the \texttt{provider} with some parameters (the scopes and the redirectionUri saved in the configuration file). Here, \textbf{AuthorizationRequestRepository.java} applies persistency to the request's state. The user is now on the provider's login/authorization page, where it can log in and allow/deny permission to the Spring Boot server. Once that it allows it, the provider sends the user to \textcolor{blue}{\texttt{\{baseUrl\}/oauth2/callback/provider}} with an AuthZ code (or an error otherwise).

At this point, \textbf{OAuth2AuthenticationFailureHandler.java} is invoked in case of failure (it redirects the user on the React app with an err message in the query string), otherwise, the flow continues and the previous callback contains the authorization code that is automatically exchanged by Spring Security for an access token. The next step involves \textbf{CustomOAuth2UserService.java} that takes all the details of the authenticated user by performing HTTP GETs to the defined endpoints available in the Google/Facebook documentation and adds/updates the database. Spring Security is really useful in this objective because it has already implemented the HTTP API calls for the most famous providers and it is almost automated. 

Finally, the last step is devoted to \textbf{OAuth2AuthenticationSuccessHandler.java}, that creates a JWT token and sends it to the React app's \texttt{redirect\_uri} previously sent at the beginning. Once that the client app receives it, it can make an HTTP GET with the JWT on the endpoint of the Spring Boot server \texttt{/user/me} to retrieve the user information and display it to the client. The generic flow with Google is available in \texttt{.svg} format\footnote{\url{https://github.com/nopesir/oauth-hw-security/releases/download/v0.5-alpha/flow.svg}} in the resources.


In Section \ref{csrf} has been discussed the problem of CSRF. In particular, the recommended way of avoiding this kind of attack is the use of a \texttt{state} parameter. When the Spring Boot server redirects the user to the provider's login page (see \hyperlink{foo}{here} the HTTP redirection link), it has to first generate this string variable and send it as HTTP parameter with the \texttt{redirect\_uri}. The provider must return this parameter unaltered in the \oauth\ callback and the server will compare the generated one with the received one. In case they don't match, the flow is stopped and the request denied.
The class \textbf{HttpCookieOAuth2AuthorizationRequestRepository.java} temporary stores the \texttt{redirection\_uri} and the \texttt{state} params in a short-lived cookie.

To gain access to the user's info, \textbf{CustomOAuth2UserService.java} implements the Spring Security's \textit{DefaultOAuth2UserService} class by its \texttt{loadUser()} method (called after that an \oauth\ \texttt{access\_token} is finally available). More in details, the method fetches what is needed from the provider and then checks the database to update it. Since the JSON structure of the responses of each provider changes, Spring Security provides a parsing layer that returns a map of key-value pairs. To manage the different providers, a generic \textbf{OAuth2UserInfo.java} is created and a factory design pattern is implemented through \textbf{OAuth2UserInfoFactory.java} to instantiate the correct \textbf{OAuth2UserInfo.java} (\textbf{GoogleOAuth2UserInfo.java}, \textbf{FacebookOAuth2UserInfo.java} and so on).

In addition to the \oauth\ login, the Spring Boot server implements the classic email/password based authentication. \textbf{AuthController.java} is responsible for controlling the REST endpoints \texttt{/auth} and \texttt{/signup}, while \textbf{CustomUserDetailsService.java} implements Spring Security's \textit{UserDetailsService} class to load the user from the database. For managing (generate/verify) the JWT tokens, a \textbf{TokenProvider.java} is created. Moreover, \textbf{TokenAuthenticationFilter.java} uses the provider one to verify the JWT and set the \textbf{SecurityContex.java}. \textbf{RestAuthenticationEntryPoint.java} checks for unauthorized accesses and returns a 401 HTTP error for it. \textbf{UserPrincipal.java} contains the details of the authenticated user while \textbf{UserController.java} implements the API for retrieving the details of it. Finally, there is a utility class that is used for the cookies management (\textbf{CookieUtils.java}), while \textbf{LoginRequest.java}, \textbf{SignUpRequest.java}, \textbf{AuthResponse.java} and \textbf{ApiResponse.java} are the request/response payloads.

For further information on Spring Security, see the documentation \cite{sprsec}.
% ------ END OF SECTION B.2.1 ------

% ------ SECTION B.2.2 ------
\subsection{\oauth\ with custom AuthZ/Resource servers}
This second implementation example is required to better understand \oauth\ and his actors without the customization of providers like Google. It is possible to build an authorization server and a resource server using the \textit{Authorization Grant Flow} (\ref{authcg}) and the \textit{Refresh Token Flow} (\ref{accref}). For this task, before consulting directly the \rfc{6749}, the developer.okta.com's article "What is the OAuth 2.0 Authorization Code Grant Type?" \cite{oauth2} is a good start. The demo is composed by three servers (actors):

\begin{itemize}
    \item \textit{Client-server}, that acts like the Spring Boot server in the previous example (the client of the \oauth\ protocol specification that is interested in accessing a resource), but without a React web app: it is used a classic routing website served directly from the server itself. This actor is a web-server from the point of view of the user and a client from the \oauth\ protocol point of view.
    \item \textit{Authorization-server}, that provides endpoints for user authentication and authorization, token access and token refresh and so on.
    \item \textit{Resource-server}, that makes available resources by using the retrieved token from the authorization server.
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.81\textwidth]{chapters/images/chp6/flow_access1.png}
    \caption{Implementation of the AuthZ Code Grant flow.}
    \label{fig:access1}
\end{figure}

There is the user too (the resource owner), that is responsible for grant/deny permissions to the client-server. All the software of this demo uses Maven for project management, dependencies and so on. Moreover, it is built on top of \texttt{Jakarta EE} \cite{jaksec} with \texttt{MicroProfile}, but more details are available in the dedicated subsections.

The first implemented flow is the \textit{Authorization code grant} that has as objective the \texttt{access\_token} and \texttt{refresh\_token} retrieval, passing through the authorization code. The flow (Fig.~\ref{fig:access1}) starts with an user interaction (this is always true if no Refresh Token flow is implemented):

\begin{enumerate}
    \item User opens \url{http://localhost:9180} and clicks "Get Access Token".
    \item User is redirected on \url{http://localhost:9180/authorize} (this starts the dedicated Servlet on the \textit{Client-server} module, more details will follow) and directly to the AuthZ Server on \url{http://localhost:9080/authorize} (see the figure for messages format and params).
    \item The AuthZ Server checks the authentication of the user. If he is not authenticated, authenticates the user and finally is presented the web-page with the checkboxes of the authorization to be granted or not (\texttt{resource\_read} and \texttt{resource\_write}). 
    \item The user gives the authorization for the two scopes (or a subset of them) and the AuthZ Server redirects the User to the \texttt{redirect\_uri} specified in step 2 with the \texttt{code} (AuthZ Code) and the \texttt{state} param for CSRF avoidance.The URI is \url{http://localhost:9180/callback}.
    \item The \textit{Client-server} takes the AuthZ Code, checks that the state param is the same as the one sent before and prepares an HTTP POST to the AuthZ Token Endpoint (\url{172.28.1.2:9080/token}) without the user interaction by using the Docker LAN.
    \item More in details, the HTTP POST is prepared by encoding the secrets in Base64url and adding the AuthZ Code, the redirection URI and the grant type as form items. There is no user interaction in this step. This step is started by the second Servlet.
    \item The AuthZ Server decodes the authorization header and checks the credentials, takes the code and generates an access token and a refresh token as later described.
    \item Furthermore, the AuthZ Server creates the JSON response by adding the signed and serialized JWT for access and for refresh, the expiration of the token (1800 seconds), the token type and the authorized scopes.
    \item Finally, the \textit{Client-server} takes the signed serialized JTW from the \texttt{access\_token} variable of the JSON and using the public key it verifies the signature. The same applies for the \texttt{refresh\_token}. It stores the access and refresh token in order to request resources to the Resource Server. There is no user interaction.
\end{enumerate}



\begin{figure}[h]
    \centering
    \includegraphics[width=0.85\textwidth]{chapters/images/chp6/flow_refresh1.png}
    \caption{Implementation of the Refresh Token flow.}
    \label{fig:refresh1}
\end{figure}

The second implemented flow is the Refresh Token flow that has as objective the \texttt{access\_token} and \texttt{refresh\_token} retrieval by consuming the \texttt{refresh\_token}. The flow presumes that the \textit{Client-server} has already performed the AuthZ Code Grant flow and has an access token (expired or not) and a refresh token (not expired). The initial interaction of the User to start the Refresh Token flow is a simple example, but the use of this flow is to avoid any user interaction after the successful outcome of a previous AuthZ Code Grant flow. For production environment, a trigger to start this flow could be the expiration of the access token. The steps (Fig.~\ref{fig:refresh1}) are the following:

\begin{enumerate}
    \item The User clicks on "Refresh token (original scope)" from the homepage (\url{http://localhost:9180}). This click triggers the third Servlet of the \textit{Client-server} module on \url{http://localhost:9180/refreshtoken}.
    \item The \textit{Client-server} prepares the HTTP POST by adding in the authorization header the Base64url encoded string with \texttt{client\_id} and \texttt{client\_secret}. Furthermore, in the form it adds the \texttt{refresh\_token} and the \texttt{grant\_type} requested. The HTTP POST is done by using the Docker LAN on \url{172.28.1.2:9080/token}.
    \item The AuthZ Server checks the authorization header and then the \texttt{grant\_type} so that it knows that the request is a \texttt{refresh\_token}. Retrieves the \texttt{refresh\_token}, verifies its validity and that it was issued for the same client. Finally it generates another \texttt{access\_token} and another \texttt{refresh\_token} for the same scopes.
    \item As the AuthZ Code Grant flow, the server builds the JSON response and replies.
    \item The \textit{Client-server} performs the checks for validity of the new two tokens and then refreshes the homepage for the User (note that this last step is not mandatory, is only for educational purposes, the user is not an active actor of the Refresh Token flow). At this point, the \textit{Client-server} can continue to use the new \texttt{access\_token}.
\end{enumerate}

I addition, it is possible to force the Refresh Token flow on a subset of the original granted scopes. For example, if the \textit{Client-server} has authorization for "resource.read" and "resource.write", there is the possibility to force only one of them during the token refresh flow by using from the homepage "Refresh token (scope: resource.read)" or "Refresh token (scope: resource.write)". 

Taking as initial state the one with only "resource.read" authorized, if the User clicks on "Refresh token (scope: resource.write)" and the authorization that the \textit{Client-server} has is not a subset of the requested one, the AuthZ Server will respond with an error message. In Fig.~\ref{fig:refresh3} is showed the same Refresh Token flow forced on the scope "resource.write". 

\begin{figure}[h]
    \centering
    \includegraphics[width=0.85\textwidth]{chapters/images/chp6/flow_refresh3.png}
    \caption{Implementation of the forced Refresh Token flow on "resource.write" with the message differences highlighted and BAD REQUEST error returned.}
    \label{fig:refresh3}
\end{figure}

Finally, once that the \textit{Client-server} has the \texttt{access\_token}, it can perform a resource request to the Resource server (Fig.~\ref{fig:resource}):

\begin{figure}[h]
    \centering
    \includegraphics[width=0.85\textwidth]{chapters/images/chp6/flow_resource.png}
    \caption{Implementation of the Resource request flow.}
    \label{fig:resource}
\end{figure}

\begin{enumerate}
    \item The User is on the homepage with the tokens displayed on the page. It has only the "resource.read" scope authorized, it clicks on the link "Read Protected Resource" (\url{http:localhost:9180/downstream?action=read})
    \item The action triggers the fourth and last Servlet of the \textit{Client-server}. It prepares an HTTP GET to \url{172.28.1.3:9280/api/resource/read} with the \texttt{access\_token} in the authorization header. There is no user interaction.
    \item The Resource Server has the public key locally (it can be modified in order to request the public key from the AuthZ Server dedicated endpoint). It verifies the JWT sent by the Client and uses the "groups" Private Claim to map the Jakarta RR Roles on the resources. In this case, "resource.read" is the only group and, since the request is "resource read", the permission is granted. It prepares the response by adding a html-formatted string that greets the User.
    \item The \textit{Client-server} receives the resource (in this cas an html document) and displays it into the browser to the User (or it can do something else with it).
    \item If the User clicks on "Write Protected Resource", it would lead to a Forbidden access, since it has authorization only to "resource.read" and not "resource.write".
    \item Forbidden access: once that the Resource Server has verified the JWT and has retrieved the "group" claim, the "resource.write" was not written in it.
    \item The \textit{Client-server} receives and injects the error as html text into the browser to the User.
\end{enumerate}

After this introduction on the general flows, in the following subsections is presented a detailed explanation of the implementation, divided into the three servers that compose the architecture.

\subsubsection{Client-server}
This web-server implements four Servlets\footnote{Exploit dynamic web content with Java, "[..] class that is used to extend the capabilities of servers that host applications accessed employing a request-response programming model.". Source: \url{https://docs.oracle.com/javaee/5/tutorial/doc/bnafe.html}}:

\begin{itemize}
    \item Request the authorization code from the authorization server's endpoint.
    \item Request the access token by consuming the authorization code.
    \item Request the access token by consuming the refresh token (\ref{accref}).
    \item Request the resource from the resource server's endpoint by consuming the access token.
\end{itemize}

\noindent Moreover, it uses MicroProfile Config for configuration files injection and JAX RS Client for accessing web resources. For simplicity, the \texttt{client\_id} and \texttt{client\_secret} are manually defined in the authorization server as it will be explained in the next subsection. This means that our client must have securely stored the two secrets that, for this demo, are only one pair (since the client is only one). In the configuration file stored in \texttt{META-INF/microprofile-config.proper-\\ties} (it must be noted that it applies the same \texttt{.template} design, as explained in the first demo), apart from the secrets, other important variables are:

\begin{itemize}
    \item \texttt{redirect\_uri}: As it was already mentioned, this is \textit{where} to receive the AuthZ code.
    \item \texttt{scope}: The permission requested by the client.
    \item \texttt{authorization\_uri}: The client needs to know where to send the request for the AuthZ code.
    \item \texttt{token\_uri}: As for the AuthZ URI, the client needs to know where to send the request to exchange the code for an access token.
\end{itemize}

\noindent It is important though to point out that the URIs are configured for the Docker virtualized network and they need to be changed to be run without Docker.

The first Servlet implements the AuthZ code request on the AuthZ server's endpoint and it is implemented in \textbf{AuthorizationCodeServlet.java} waiting to start on the \texttt{/authorization} endpoint of the client. More in details, the Servlet creates and stores the \texttt{state} param, retrieves the information from the MicroProfile Config file and builds the URI attaching all the variables. Finally, it redirects the user to the built URI (that is on the AuthZ server). After processing the request, the AuthZ server will redirect back the user to the client with the AuthZ code and the same \texttt{state} param on the URI \textcolor{blue}{\texttt{http://localhost:9180/callback?code=1\&state=tugh-\\dj57gh5h7t7fdhgwejgg}} where the second Servlet is waiting for the AuthZ code (the client server is on 9180, the AuthZ server is on 9080 and the resource server on 9280).

The second Servlet starts as soon as the AuthZ server redirects back to \texttt{/callback} with the AuthZ code and the \texttt{state} as parameters (is the only Servlet not triggered by the user in this implementation). The implementation is in \textbf{CallbackServlet.java}. First, it checks the \texttt{state} match and then it uses the received code to request an access token. In this case, there is no browser interaction, it is all implemented through HTTP POST and JAX RS Client: here the token endpoint requires the two secrets too in the \textit{Authentication} header, along with the code, the type of the code and the redirect URI. Now the client has the access token (and the refresh token too) and it can access information on the resource server by using the third Servlet implemented in \textbf{DownstreamCallServlet.java} waiting on \texttt{/downstram} with two actions passed as query params: \textit{read} or \textit{write}. Based on the action, the Servlet calls the resource server's APIs with the access token in the Authorization HTTP header and receives a string if it has access or an HTTP Forbidden error if it does not.

The last Servlet is used to obtain a new access token starting from the refresh token. This is useful because it does not require the user to repeat all the flow. The Servlet is ready to start at \texttt{/refreshtoken} and, similarly to the code in \textbf{CallbackServlet.java}, it uses only JAX RS Client and HTTP POST to build the request, that has the refresh token, the scopes and as grant type \texttt{refresh\_token}. The Authentication header with the encoded secrets is added too. The request is posted on the same token endpoint of the AuthZ server, but the AuthZ server will know what to do because of the \texttt{grant\_type} param. If the response is 200 HTTP, the new access token and the new refresh token are stored and they can be used for the next calls.

To start the first Servlet and/or to know every parameter and token (for educational purposes), a simple homepage is built (\texttt{src/main/webapp/}\textbf{index.jsp}) that in a few words prints all the information and makes available the endpoints (by mouse click) to the user.

\subsubsection{Authorization-server}
This server is the core of the \oauth\ implementation. For simplicity, a pre-configured client and a pre-configured user are used, stored in \texttt{src/main/resources/data.sql.template} (it must be pointed out though that for a production environment the passwords must be hashed). 

The first important endpoint is the AuthZ endpoint that is responsible for the authentication of the user to subsequently ask for the needed permissions. The Section 3.1 of the \rfc{6749} states that "The authorization server MUST support the use of the HTTP "GET" method [\rfc{2616}] for the authorization endpoint and MAY support the use of the "POST" method as well.". In this implementation is preferred the HTTP GET method alone. Since the specification does not ask for a particular login flow, a simple login form with Jakarta EE Security can be used. The file \textbf{AuthorizationEndpoint.java} contains:

\begin{itemize}
    \item \texttt{@FormAuthenticationMechanismDefinition} to ensure that the user is logged to proceed.
    \item HTTP GET Servlet that checks the validity of the secrets, the redirect URI, the requested scope and saves all this params in the session and redirects the user to \textbf{authorization.jsp} from where it selects what to authorize with some checkboxes.
    \item HTTP POST Servlet that receives the user checkboxes from \textbf{authorization.jsp}, uses the saved params in the preceding point to populate a new AuthZ code model with the authorization code, the \texttt{client\_id}, the approved scopes, the expiration date and so on and redirects back to the client on the \texttt{redirect\_uri} by adding to the query params the new code alongside the state received at the beginning for avoiding CSRF. The \texttt{redirect\_uri} must exist in the table as an authorized URI for redirections.
\end{itemize}

\noindent As mentioned before, retrieving the access token starting from the authorization token is an action that does not require the user nor the browser intervention. The token endpoint of the AuthZ server, under the \textit{client-server}, uses JAX RS to expose the endpoint. The class \textbf{TokenEndpoint.java} implements the next step of the workflow: retrieve the access token. The Servlet accepts only HTTP POST and, as mentioned in the \oauth\ specification, accepted parameters mus be \texttt{application/x-www-form-urlencoded}. The first thing that the Servlet checks is the \texttt{grant\_type} that must be \texttt{authorization\_code} since this is an AUthZ Code Grant flow implementation. The second check is on \texttt{client\_id} and \texttt{client\_secret} that are in the Authorization header of the received post (this is required by the protocol to identify the client). The two secrets are encoded into Base64url following this conversion:

  \texttt{BASE64URL(client\_id:client\_secret)}

\noindent Finally, the Servlet creates the access token by using \textbf{AuthorizationCodeGrantTypeHandler.java}. 

Since the endpoint can and should be used for both the requests of getting an access token starting from an authorization code or getting an access token starting from a refresh token, the Servlet must be dynamically capable of choosing the right class instance. A possible solution is an implementation through the \textit{Contexts and Dependency Injection} (CDI). More in details, the \textbf{AuthorizationGrantTypeHandler.java} interface is created and implemented with \textbf{AuthorizationCodeGrantTypeHandler.java} for AuthZ code to access token and with \textbf{RefreshTokenGrantTypeHandler.java} for refresh token to access token. Each class is decorated with \texttt{@Named} that specifies for the first one the \texttt{authorization\_code} type and the second one the \texttt{refresh\_token} type. By using the decoration, in the Servlet can be written a single line of code that uses the received string (\texttt{grantType}) on the endpoint and uses it directly to load one handler or the other one:

\texttt{AuthorizationGrantTypeHandler authorizationGrantTypeHandler = } 

\hspace{0.8cm} \texttt{authorizationGrantTypeHandlers.select(NamedLiteral.of(grantType)).get();}

\noindent To generate tokens though, it is required that the server signs them with a private RSA key. It has been used OpenSSL to generate the private key:
 
  \texttt{\$ openssl genpkey -algorithm RSA -out private-key.pem \textbackslash}
  
  \hspace{0.8cm} \texttt{-pkeyopt rsa\_keygen\_bits:2048}

\noindent And the path to this key is saved in \texttt{resources/META-INF/microprofile-config.properties} to be injected into the server configuration info to be loaded directly from the code. Alongside the private key, a corresponding public key is generated:
 
  \texttt{\$ openssl rsa -pubout -in private-key.pem -out public-key.pem}

\noindent And stored in the same configuration file.

When the resource server receives a request with an access token for a resource, it has to verify it by using the public key. Another endpoint is necessary on the AuthZ server: a JWK [\rfc{7517}] for public key distribution. This endpoint is mapped in \texttt{/jwk} and the Servlet is implemented by the class \textbf{JWKEndpoint.java}. Thanks to the Nimbus library, the code is much more simplified with both the JWT and PEM formats compatibility (by specifying the param \texttt{format} in the URI query).

For what concerns the authorization endpoint, it was already mentioned the existence of \textbf{AuthorizationGrantTypeHandler.java}, but how does it work? What does the endpoint returns? More in details, it uses the Nimbus JOSE library for creating a JWT token. The first thing to do is to create a JWT header and then populate the payload with some claims (like the issuer, the claimer and so on). Then, the token must be signed with the RSA Private Key. This step can be divided into two: 

\begin{itemize}
    \item The JWT is created starting from the claims and the header.
    \item The \textit{RSASSASigner} object uses the imported PEM key to sign the JWT.
\end{itemize}

\noindent Finally, the JWT is ready and it is serialized into a \textit{String}. More in details, this serialization follows the "JWS Compact Serialization" defined in Section 7.1 of the \rfc{7515} \cite{RFC7515}:

  \texttt{BASE64URL(UTF8(JWS Protected Header)) || '.' ||}
  
  \texttt{BASE64URL(JWS Payload) || '.' ||}
  
  \texttt{BASE64URL(JWS Signature)}

\noindent An example of a valid serialized JWT for this implementation could be:

\begin{lstlisting}[basicstyle=\ttfamily]
  eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9
  .
  eyJzdWIiOiJhcHB1c2VyIiwiYXVkIjoiaHR0cDpcL1wvMTcyLjI4LjEuMzo5Mjg
  wIiwidXBuIjoiYXBwdXNlciIsIm5iZiI6MTU5Mzc5MDY1MSwic2NvcGUiOiJyZX
  NvdXJjZS5yZWFkIiwiaXNzIjoiaHR0cDpcL1wvMTcyLjI4LjEuMjo5MDgwIiwiZ
  3JvdXBzIjpbInJlc291cmNlLnJlYWQiXSwiZXhwIjoxNTkzNzkyNDUxLCJpYXQi
  OjE1OTM3OTA2NTEsImNsaWVudF9pZCI6IndlYmFwcGNsaWVudCIsImp0aSI6ImI
  3MmNiOTc2LTgxY2ItNGRjNi1hMjMwLTg2YzE2ZTE1NWQyNiJ9
  .
  pVjwobEPgfjLMdVHdBKNhwNcqpG9UytZH2wcJYtVuVFitgaDk6cWwTCCJlOLLO
  qcvtXsl4RjXavKFFGVIalQL1Smqj69u6i98VqRVn6yRiPyi8EDJeJn6Xa2BjIF
  ePjPc8EyejvM47F0LDwJO19kb-s8fcXKqEdB0zTQ8vMvb-1jgk9KlXWzsT3HxN
  rRLnpHyUAWjELVe30awwF0v9MfGPdxX64Kq62hNA2hg8TLLHXWEgU1v5eqCmdk
  sD1kyhS_cPSQLRKcXQMDPdTe1H4cnXnm8Gl_qYV885RYLx0DXqddWoiRPCLu
  5RbLr2ZXxAOSFQ8kKScmXX3BUpkiHS5afw

  
\end{lstlisting}

\noindent Where the first part of the string is the Base64url encoded JOSE Header that specifies the used algorithm and the type. The decoded string would be:

\begin{lstlisting}[basicstyle=\ttfamily]
  {
    "typ":"JWT",
    "alg":"RS256"
  }
\end{lstlisting}

\noindent The second part represents the encoded JWS Payload with all the previously built claims, decoded as:

\begin{lstlisting}[basicstyle=\ttfamily]
  {
    "sub":"appuser",
    "aud":"http://172.28.1.3:9280",
    "upn":"appuser",
    "nbf":1593790651,
    "scope":"resource.read",
    "iss":"http://172.28.1.2:9080",
    "groups":["resource.read"],
    "exp":1593792451,
    "iat":1593790651,
    "client_id":"webappclient",
    "jti":"b72cb976-81cb-4dc6-a230-86c16e155d26"
  }
\end{lstlisting}

\noindent Where, according to the \rfc{7519}\ specification \cite{RFC7519}, are defined the following Registered Claim Names:

\begin{itemize}
    \item \texttt{sub}: OPTIONAL. The principal that is the subject to the JWT.
    \item \texttt{aud}: OPTIONAL. Audience, to whom the JWT is addressed.
    \item \texttt{nbf}: OPTIONAL. Not Before, "the time before which the JWT MUST NOT be accepted for processing." \cite{RFC7519}
    \item \texttt{iss}: OPTIONAL. The issuer of the JWT.
    \item \texttt{exp}: OPTIONAL. The expiration time.
    \item \texttt{iat}: OPTIONAL. Issued At.
    \item \texttt{jti}: OPTIONAL. JWT ID, a unique identifier for the JWT.
\end{itemize}

\noindent And the following Private Claim Names designed for the demo:

\begin{itemize}
    \item \texttt{upn}: To be mapped into Jakarta EE Security \textit{CallerPrincipal}.
    \item \texttt{groups}: To be mapped into Jakarta EE \textit{Roles}.
    \item \texttt{client\_id}: The ID of the \oauth\ web-server client.
\end{itemize}

\noindent These claims are built in the token endpoint response code in the \textbf{AbstractGrantTypeHandler.java} class. For what concerns the \texttt{refresh\_token}, the JWT is similar, with few claims and expiration of one day.
Finally, the third and last part of the JWT represents the Base64url encoded JWS Signature performed by the server on the following octets:
\begin{lstlisting}[basicstyle=\ttfamily]
  ASCII(
    BASE64URL(UTF8(JWS Protected Header)) || '.' ||
    BASE64URL(JWS Payload)
  )
\end{lstlisting}

\noindent Those octets are signed using \textit{RSASSA-PKCS1-v1\_5} with the \textit{SHA-256} hash algorithm (defined as \texttt{RS256} in the JOSE Header) by the server and finally encoded in Base64url.

The last thing to do is build the JSON response and add the elements and the serialized JWTs (refresh and access tokens) to return the information requested by the client. This step is implemented in the \textbf{AuthorizationCodeGrantTypeHandler.java} class, that once it has serialized the two JWTs, it builds the response:

\begin{lstlisting}[language=bash, basicstyle=\ttfamily]
  {
    "access_token": "averylongstring,seepage46" ,
    "token_type": "Bearer",  
    "expires_in": 1800,
    "scope": "resource.read",
    "refresh_token": "smallerthanaccesstoken,lessclaims"
  }
\end{lstlisting}

A detailed diagram of the AuthZ Code Grant flow for this implementation is available in the resources as \texttt{flow\_access-token.svg}\footnote{\url{https://github.com/nopesir/oauth-hw-security-custom/releases/download/v1.0/flow_access-token.svg}}, while a detailed diagram of the Refresh Token flow is available in the resources as \texttt{flow\_refresh-token.svg}\footnote{\url{https://github.com/nopesir/oauth-hw-security-custom/releases/download/v1.0/flow_refresh-token.svg}}.

\subsubsection{Resource-server}
This third and last server exposes the APIs to the client for accessing the user's information by consuming the access token retrieved in the previous steps. This server uses JAX RS and MicroProfile. In particular, MicroProfile JWT is responsible for the validation and the mapping of the scopes in Jakarta roles. Thanks to these libraries, the code is pretty simple. In particular, the class \textbf{OAuth2ResourceServerApplication.java} is decorated with \texttt{@DeclareRoles} to define the scopes available and \texttt{@LoginConfig} to specify the authentication method. Finally, the class \textbf{ProtectedResource.java} represents the resource (in terms of called function) that can be personalized to return a file or any other protected information (in this example, it is a string).

It must be pointed out that even if the AuthZ server implements the JWT endpoint, it has been chosen to add the key directly in the server's resources (to use the endpoint, the path in the configuration file has to be replaced with the endpoint of the AuthZ server).
% ------ END OF SECTION B.2.2 ------
% ------ END OF SECTION B.2 ------

% ------ SECTION B.3 ------
\section{Dockerization}
To best manage, debug and deploy the two solutions, it has been chosen to dockerize the single servers. More in details, every module has its own \textbf{Dockerfile} and each demo has its \textbf{docker-compose-build.yaml} to build and run at the same time all the modules with the network configuration. Moreover, pre-built images are available on Docker Hub and a special \textbf{docker-compose.yaml} for each solution can be used to rapidly pull all the images without wasting time to build (this is mainly done for the User Guide to rapidly test and run the examples).
An important note about the example with Google/Facebook before its compilation: set \texttt{client\_id} and \texttt{client\_secret} retrieved from the registration process in Section \ref{regprocess} into the \textbf{docker-compose-build.yaml} file.

% ------ SECTION B.3.1 ------
\subsection{\oauth\ with Google/Facebook}
The first demo has two modules: the React web-app and the Spring Boot JAVA server. Each of them has its \textbf{Dockerfile}. In particular, in the React web-app, there is a two-staged docker build:

\begin{itemize}
    \item The app is built by using as base image \texttt{node:12.4.0-alpine}, producing the web-app.
    \item The web-app is copied in a simple \texttt{nginx:1.17.0-alpine} image that implements the NGINX server alongside a standard \textbf{nginx.conf}, exposing the tcp/9090 port to \texttt{localhost}.
\end{itemize}

\noindent In the Spring Boot server, the approach is similar:

\begin{itemize}
    \item The server is built using as base image \texttt{openjdk:8-jdk-alpine} with the \texttt{mvnw} command (Maven Wrapper). Moreover, the configuration files are modified according to the different arguments passed.
    \item After that the application is packed in a \texttt{.jar}, the second stage uses \texttt{openjdk:8-jre-alpine} (a minimal image) to copy the package and run the server once that the container starts up.
\end{itemize}

These Dockerfiles are not meant to be used singularly but through \texttt{docker-compose}. The \textbf{docker-compose-build.yaml} file is responsible to use each \textbf{Dockerfile} to build the images, expose the containers in predefined ports and create some basic container network configuration. To start the local build and run the demo, the command is

  \texttt{\$ docker-compose -f docker-compose-build.yaml up}

\noindent That builds everything from scratch. The command needs time (there are some tasks like \texttt{npm install} that are heavy), but in the end, the two modules will be ready to test. The \textbf{docker-compose.yaml} can be used instead for a quicker run without build.

It is really important to type the same command with the \texttt{down} option when the test is finished in order to release all the residual resources of Docker.
% ------ END OF SECTION B.3.1 ------

% ------ SECTION B.3.2 ------
\subsection{\oauth\ with custom AuthZ/Resource servers}
The dockerization design of the second example is identical to the first one: a \textbf{Dockerfile} for each server module that are used only by the \textbf{docker-compose-build.yaml} to entirely build and run locally the solution. The three servers use Open Liberty as server run-time, integrated with the project as Maven dependency. Moreover, some arguments are editable from the compose to correctly print personalized version of the configuration file (e.g. for the user definition or for the secrets definition).

The network namespace is configured as a simple LAN on \texttt{172.28.0.0/16} and the three servers are placed as follows:

\begin{itemize}
    \item Client server: 172.28.1.1 on tcp/9180
    \item AuthZ server: 172.28.1.2 on tcp/9080
    \item Resource server: 172.28.1.3 on tcp/9280
\end{itemize}

The client and the authorization servers have the exposed ports on the local guest machine to be reachable from the user during the redirections of the protocol itself. The resource server is not accessible from the host, but only indirectly from the client server through its APIs and using the access tokens (to provide basic isolation of the resources).
\label{docker}

Finally, to analyze and debug the messages exchanged in the Docker LAN, it has been used the \texttt{netshoot} \cite{netsh} container tool alongside \texttt{termshark} \cite{terms}. To catch all the HTTP exchanged messages from one of the three containers, simply run:

  \texttt{\$ docker run -it --rm --net \textbackslash}
  
  \hspace{0.8cm} \texttt{container:<container\_name> \textbackslash} 
      
  \hspace{0.8cm} \texttt{--cap-add=NET\_ADMIN --cap-add=CAP\_NET\_RAW nicolaka/netshoot \textbackslash}

  \hspace{0.8cm} \texttt{termshark -i eth0 -Y http}

\noindent As an example, if the container name of the Client (\texttt{oauth-hw-security-custom\_app-server\_1}) is set, it is possible to capture the AuthZ Code request and the JSON response of the AuthZ Server with the \texttt{access\_token} as shown in Fig.~\ref{fig:netshoot}.

\begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{chapters/images/chp6/netshoot.png}
    \caption{Termshark running on Netshoot: caption of the access token JSON response from the AuthZ Server to the Client.}
    \label{fig:netshoot}
\end{figure}
% ------ END OF SECTION B.3.2 ------
% ------ END OF SECTION B.3 ------

% ------ END OF APPENDIX B ------